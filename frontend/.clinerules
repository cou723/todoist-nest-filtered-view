# パッケージ管理ツールはpnpmを使用してください
# npmコマンドの代わりにpnpmコマンドを使用してください
# 例:
#   npm install → pnpm install
#   npm run build → pnpm run build
#   npm exec eslint → pnpm exec eslint
# プロジェクトの概要
このプロジェクトはユーザーの特定の条件に沿ったTodoistのタスクを取得し、そのタスクの親タスクの名前を含めて表示するクライアントアプリケーションです。
## 技術スタック
- パッケージ管理ツール: pnpm
- フレームワーク: Lit

## 課題感
既存のアプリケーションでは条件でフィルタリングするとタスクの親タスクの名前が表示されず、ユーザーが親タスクの情報を得るために別の操作を行う必要がありました。

## 解決策
このアプリケーションでは、ユーザーが指定した条件に合致するタスクを取得し、そのタスクの親タスクの名前も同時に表示します。これにより、ユーザーは親タスクの情報を簡単に確認できるようになります。


# 姿勢
- わからない個所や不明点がある場合は、なるべく推測せずユーザーに聞く

# コンポーネント設計ガイドライン
## スタイルの責務分離
- 共通スタイルはスコープが広すぎるため推奨されない
- ボタンやインプットなどの基本UIコンポーネントは、それぞれ独立したコンポーネントとして作成し、そこにスタイルを記述する
- 各コンポーネントは自身のスタイルを持ち、外部のスタイルに依存しない設計とする
- 共通スタイルは、レイアウト関連の最小限のユーティリティクラスのみに留める

## UIコンポーネントの設計原則
- ボタン、入力フィールドなどの基本UIコンポーネントは`src/components/ui/`ディレクトリに配置する
- 各UIコンポーネントは独立して動作し、再利用可能な設計とする
- UIコンポーネントは自身のスタイルを完全に内包する
- プロパティとイベントを通じて外部とのやり取りを行う

## 条件付きレンダリングのガイドライン
- 「条件がtruthyなら表示し、そうでなければ何も表示しない」場合は、`when`ユーティリティ関数を使用する
- Litでは論理AND演算子（`&&`）を使うとfalsy値（`false`、`0`など）がそのまま表示されてしまうため避ける
- `when`関数は`src/utils/template-utils.ts`で定義されており、内部的に三項演算子と`nothing`を使用している
- 例: `${when(isVisible, html`<div>表示内容</div>`)}` （推奨：簡潔で読みやすい）
- 例: `${isVisible ? html`<div>表示内容</div>` : nothing}` （代替案：直接的だが冗長）
- 例: `${isVisible && html`<div>表示内容</div>`}` （非推奨：falsyの場合に値が表示される）

### when関数の使用例
```typescript
// 基本的な使用
${when(user, html`<span>Hello, ${user.name}!</span>`)}

// 複合条件
${when(items && items.length > 0, html`<ul>...</ul>`)}

// オプショナルチェーンとの組み合わせ
${when(user?.isAdmin, html`<button>管理者メニュー</button>`)}
```

## タスク終了時のチェック
タスク終了時のチェックはユーザーがするので開発用サーバーなどは立ち上げず`pnpm run build`でビルドして動作確認を行うこと。
# テスト環境
- テストはvitestを使用してください
- テスト実行は`pnpm run test`で行います
- テストファイルは`src/**/*.test.ts`のパターンで管理してください